import tgpu, { TgpuRoot } from 'typegpu';
import { describe, expect, test, vi } from 'vitest';
import { ByeGLContext } from '../src/byegl-context';
import * as byegl from '../src/index.ts';
import { ShaderkitWGSLGenerator } from '../src/wgsl/shaderkit-wgsl-generator.ts';

const rootMock = {
  device: {},
} as TgpuRoot;

const canvasMock = {
  width: 100,
  height: 100,
  getContext: () => ({ configure: () => {} }),
} as unknown as HTMLCanvasElement;

describe('float uniform', () => {
  test('shader generation', () => {
    const glslVert = `
      uniform float uFoo;
    `;

    const glslFrag = `
    `;

    const gl = new ByeGLContext(
      2,
      rootMock,
      canvasMock,
      new ShaderkitWGSLGenerator(),
    ) as unknown as WebGL2RenderingContext;

    const vert = gl.createShader(gl.VERTEX_SHADER)!;
    gl.shaderSource(vert, glslVert);
    const frag = gl.createShader(gl.FRAGMENT_SHADER)!;
    gl.shaderSource(frag, glslFrag);
    const program = gl.createProgram();
    gl.attachShader(program, vert);
    gl.attachShader(program, frag);
    gl.linkProgram(program);

    expect(byegl.getWGSLSource(gl, program)).toMatchInlineSnapshot(`
      "// Generated by byegl

      var<private> gl_Position: vec4<f32>;
      var<private> gl_FragColor: vec4<f32>;

      @group(0) @binding(0) var<uniform> uFoo: f32;

      struct _byegl_VertexOut_2 {
        @builtin(position) _byegl_posOut_3: vec4f,

      }


      @vertex
      fn _byegl_vert_main_4() -> _byegl_VertexOut_2 {


        _byegl_fake_vertex_0();
        var output: _byegl_VertexOut_2;
        output._byegl_posOut_3 = gl_Position;
        // NOTE: OpenGL uses z in the range [-1, 1], while WebGPU uses z in the range [0, 1].
        output._byegl_posOut_3.z = output._byegl_posOut_3.z * 0.5 + 0.5;

        return output;
      }

      @fragment
      fn _byegl_frag_main_5() -> @location(0) vec4f {
        // Filling proxies with varying data

        _byegl_fake_fragment_1();
        return gl_FragColor;
      }
      "
    `);
  });
});
